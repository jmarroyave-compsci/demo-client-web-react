(self["webpackChunkreact"] = self["webpackChunkreact"] || []).push([["vendors-node_modules_react-minimal-pie-chart_dist_index_js"],{

/***/ "./node_modules/react-minimal-pie-chart/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/react-minimal-pie-chart/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

(function (global, factory) {
   true ? factory(exports, __webpack_require__(/*! react */ "./node_modules/react/index.js")) :
  0;
}(this, (function (exports, React) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

  function degreesToRadians(degrees) {
    return degrees * Math.PI / 180;
  }
  function valueBetween(value, min, max) {
    if (value > max) return max;
    if (value < min) return min;
    return value;
  }
  function extractPercentage(value, percentage) {
    return percentage / 100 * value;
  }
  function bisectorAngle(startAngle, lengthAngle) {
    return startAngle + lengthAngle / 2;
  }
  function shiftVectorAlongAngle(angle, distance) {
    var angleRadians = degreesToRadians(angle);
    return {
      dx: distance * Math.cos(angleRadians),
      dy: distance * Math.sin(angleRadians)
    };
  }
  function isNumber(value) {
    return typeof value === 'number';
  }
  function functionProp(prop, payload) {
    return typeof prop === 'function' ? prop(payload) : prop;
  }

  function sumValues(data) {
    var sum = 0;

    for (var i = 0; i < data.length; i++) {
      sum += data[i].value;
    }

    return sum;
  } // Append "percentage", "degrees" and "startAngle" to each data entry


  function extendData(_ref) {
    var data = _ref.data,
        totalAngle = _ref.lengthAngle,
        totalValue = _ref.totalValue,
        paddingAngle = _ref.paddingAngle,
        chartStartAngle = _ref.startAngle;
    var total = totalValue || sumValues(data);
    var normalizedTotalAngle = valueBetween(totalAngle, -360, 360);
    var numberOfPaddings = Math.abs(normalizedTotalAngle) === 360 ? data.length : data.length - 1;
    var singlePaddingDegrees = Math.abs(paddingAngle) * Math.sign(totalAngle);
    var degreesTakenByPadding = singlePaddingDegrees * numberOfPaddings;
    var degreesTakenByPaths = normalizedTotalAngle - degreesTakenByPadding;
    var lastSegmentEnd = 0;
    var extendedData = []; // @NOTE: Shall we evaluate percentage accordingly to dataEntry.value's sign?

    for (var i = 0; i < data.length; i++) {
      var dataEntry = data[i];
      var valueInPercentage = total === 0 ? 0 : dataEntry.value / total * 100;
      var degrees = extractPercentage(degreesTakenByPaths, valueInPercentage);
      var startAngle = lastSegmentEnd + chartStartAngle;
      lastSegmentEnd = lastSegmentEnd + degrees + singlePaddingDegrees;
      extendedData.push(Object.assign({
        percentage: valueInPercentage,
        startAngle: startAngle,
        degrees: degrees
      }, dataEntry));
    }

    return extendedData;
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function ReactMinimalPieChartLabel(_ref) {
    _ref.dataEntry;
        _ref.dataIndex;
        var props = _objectWithoutPropertiesLoose(_ref, ["dataEntry", "dataIndex"]);

    return /*#__PURE__*/React__default['default'].createElement("text", Object.assign({
      dominantBaseline: "central"
    }, props));
  }

  function round(number) {
    var divisor = 1e14; // 14 decimals

    return Math.round((number + Number.EPSILON) * divisor) / divisor;
  }

  function evaluateTextAnchorPosition(_ref) {
    var labelPosition = _ref.labelPosition,
        lineWidth = _ref.lineWidth,
        labelHorizontalShift = _ref.labelHorizontalShift;
    var dx = round(labelHorizontalShift); // Label in the vertical center

    if (dx === 0) {
      return 'middle';
    } // Outward label


    if (labelPosition > 100) {
      return dx > 0 ? 'start' : 'end';
    } // Inward label


    var innerRadius = 100 - lineWidth;

    if (labelPosition < innerRadius) {
      return dx > 0 ? 'end' : 'start';
    } // Overlying label


    return 'middle';
  }

  function renderLabelElement(renderLabel, labelProps) {
    var label = renderLabel(labelProps);

    if (typeof label === 'string' || typeof label === 'number') {
      return /*#__PURE__*/React__default['default'].createElement(ReactMinimalPieChartLabel, Object.assign({
        key: "label-" + (labelProps.dataEntry.key || labelProps.dataIndex)
      }, labelProps), label);
    }

    if (React__default['default'].isValidElement(label)) {
      return label;
    }

    return null;
  }

  function renderLabels(data, props) {
    return data.map(function (dataEntry, index) {
      var _functionProp;

      var segmentsShift = (_functionProp = functionProp(props.segmentsShift, index)) != null ? _functionProp : 0;
      var distanceFromCenter = extractPercentage(props.radius, props.labelPosition) + segmentsShift;

      var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(dataEntry.startAngle, dataEntry.degrees), distanceFromCenter),
          dx = _shiftVectorAlongAngl.dx,
          dy = _shiftVectorAlongAngl.dy; // This object is passed as argument to the "label" function prop


      var labelRenderProps = {
        x: props.center[0],
        y: props.center[1],
        dx: dx,
        dy: dy,
        textAnchor: evaluateTextAnchorPosition({
          labelPosition: props.labelPosition,
          lineWidth: props.lineWidth,
          labelHorizontalShift: dx
        }),
        dataEntry: dataEntry,
        dataIndex: index,
        style: functionProp(props.labelStyle, index)
      };
      return props.label && renderLabelElement(props.label, labelRenderProps);
    });
  }

  var partialCircle = function partialCircle(cx, cy, r, start, end) {
    var length = end - start;
    if (length === 0) return [];
    var fromX = r * Math.cos(start) + cx;
    var fromY = r * Math.sin(start) + cy;
    var toX = r * Math.cos(end) + cx;
    var toY = r * Math.sin(end) + cy;
    var large = Math.abs(length) <= Math.PI ? '0' : '1';
    var sweep = length < 0 ? '0' : '1';
    return [['M', fromX, fromY], ['A', r, r, 0, large, sweep, toX, toY]];
  };

  var svgPartialCircle = partialCircle;

  function makePathCommands(cx, cy, startAngle, lengthAngle, radius) {
    var patchedLengthAngle = valueBetween(lengthAngle, -359.999, 359.999);
    return svgPartialCircle(cx, cy, // center X and Y
    radius, degreesToRadians(startAngle), degreesToRadians(startAngle + patchedLengthAngle)).map(function (command) {
      return command.join(' ');
    }).join(' ');
  }
  function ReactMinimalPieChartPath(_ref) {
    var cx = _ref.cx,
        cy = _ref.cy,
        lengthAngle = _ref.lengthAngle,
        lineWidth = _ref.lineWidth,
        radius = _ref.radius,
        _ref$shift = _ref.shift,
        shift = _ref$shift === void 0 ? 0 : _ref$shift,
        reveal = _ref.reveal,
        rounded = _ref.rounded,
        startAngle = _ref.startAngle,
        title = _ref.title,
        props = _objectWithoutPropertiesLoose(_ref, ["cx", "cy", "lengthAngle", "lineWidth", "radius", "shift", "reveal", "rounded", "startAngle", "title"]);

    var pathRadius = radius - lineWidth / 2; //@NOTE This shift might be rendered as a translation in future

    var _shiftVectorAlongAngl = shiftVectorAlongAngle(bisectorAngle(startAngle, lengthAngle), shift),
        dx = _shiftVectorAlongAngl.dx,
        dy = _shiftVectorAlongAngl.dy;

    var pathCommands = makePathCommands(cx + dx, cy + dy, startAngle, lengthAngle, pathRadius);
    var strokeDasharray;
    var strokeDashoffset; // Animate/hide paths with "stroke-dasharray" + "stroke-dashoffset"
    // https://css-tricks.com/svg-line-animation-works/

    if (isNumber(reveal)) {
      var pathLength = degreesToRadians(pathRadius) * lengthAngle;
      strokeDasharray = Math.abs(pathLength);
      strokeDashoffset = strokeDasharray - extractPercentage(strokeDasharray, reveal);
    }

    return /*#__PURE__*/React__default['default'].createElement("path", Object.assign({
      d: pathCommands,
      fill: "none",
      strokeWidth: lineWidth,
      strokeDasharray: strokeDasharray,
      strokeDashoffset: strokeDashoffset,
      strokeLinecap: rounded ? 'round' : undefined
    }, props), title && /*#__PURE__*/React__default['default'].createElement("title", null, title));
  }

  function combineSegmentTransitionsStyle(duration, easing, customStyle) {
    // Merge chart's animation CSS transition with "transition" found to customStyle
    var transition = "stroke-dashoffset " + duration + "ms " + easing;

    if (customStyle && customStyle.transition) {
      transition = transition + "," + customStyle.transition;
    }

    return {
      transition: transition
    };
  }

  function getRevealValue(props) {
    //@NOTE When animation is on, chart has to be fully revealed when reveal is not set
    if (props.animate && !isNumber(props.reveal)) {
      return 100;
    }

    return props.reveal;
  }

  function makeEventHandler(eventHandler, payload) {
    return eventHandler && function (e) {
      eventHandler(e, payload);
    };
  }

  function renderSegments(data, props, revealOverride) {
    // @NOTE this should go in Path component. Here for performance reasons
    var reveal = revealOverride != null ? revealOverride : getRevealValue(props);
    var radius = props.radius,
        _props$center = props.center,
        cx = _props$center[0],
        cy = _props$center[1];
    var lineWidth = extractPercentage(radius, props.lineWidth);
    var paths = data.map(function (dataEntry, index) {
      var segmentsStyle = functionProp(props.segmentsStyle, index);
      return /*#__PURE__*/React__default['default'].createElement(ReactMinimalPieChartPath, {
        cx: cx,
        cy: cy,
        key: dataEntry.key || index,
        lengthAngle: dataEntry.degrees,
        lineWidth: lineWidth,
        radius: radius,
        rounded: props.rounded,
        reveal: reveal,
        shift: functionProp(props.segmentsShift, index),
        startAngle: dataEntry.startAngle,
        title: dataEntry.title,
        style: Object.assign({}, segmentsStyle, props.animate && combineSegmentTransitionsStyle(props.animationDuration, props.animationEasing, segmentsStyle)),
        stroke: dataEntry.color,
        tabIndex: props.segmentsTabIndex,
        onBlur: makeEventHandler(props.onBlur, index),
        onClick: makeEventHandler(props.onClick, index),
        onFocus: makeEventHandler(props.onFocus, index),
        onKeyDown: makeEventHandler(props.onKeyDown, index),
        onMouseOver: makeEventHandler(props.onMouseOver, index),
        onMouseOut: makeEventHandler(props.onMouseOut, index)
      });
    });

    if (props.background) {
      paths.unshift( /*#__PURE__*/React__default['default'].createElement(ReactMinimalPieChartPath, {
        cx: cx,
        cy: cy,
        key: "bg",
        lengthAngle: props.lengthAngle,
        lineWidth: lineWidth,
        radius: radius,
        rounded: props.rounded,
        startAngle: props.startAngle,
        stroke: props.background
      }));
    }

    return paths;
  }

  var defaultProps = {
    animationDuration: 500,
    animationEasing: 'ease-out',
    center: [50, 50],
    data: [],
    labelPosition: 50,
    lengthAngle: 360,
    lineWidth: 100,
    paddingAngle: 0,
    radius: 50,
    startAngle: 0,
    viewBoxSize: [100, 100]
  };
  function ReactMinimalPieChart(props) {
    var _useState = React.useState(props.animate ? 0 : null),
        revealOverride = _useState[0],
        setRevealOverride = _useState[1];

    React.useEffect(function () {
      if (props.animate) {
        return startInitialAnimation();
      }

      function startInitialAnimation() {
        var animationTimerId;
        var animationRAFId;
        animationTimerId = setTimeout(function () {
          animationTimerId = null;
          animationRAFId = requestAnimationFrame(function () {
            animationRAFId = null;
            setRevealOverride(null); // Start animation
          });
        });
        return function () {
          animationTimerId && clearTimeout(animationTimerId);
          animationRAFId && cancelAnimationFrame(animationRAFId);
        };
      }
    }, []);
    var extendedData = extendData(props);
    return /*#__PURE__*/React__default['default'].createElement("svg", {
      viewBox: "0 0 " + props.viewBoxSize[0] + " " + props.viewBoxSize[1],
      width: "100%",
      height: "100%",
      className: props.className,
      style: props.style
    }, renderSegments(extendedData, props, revealOverride), props.label && renderLabels(extendedData, props), props.children);
  }
  ReactMinimalPieChart.defaultProps = defaultProps;

  exports.PieChart = ReactMinimalPieChart;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.js.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmVhY3QtbWluaW1hbC1waWUtY2hhcnRfZGlzdF9pbmRleF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyw0Q0FBTztBQUNqRyxFQUFFLENBQ21JO0FBQ3JJLENBQUMsb0NBQW9DOztBQUVyQyx1Q0FBdUMsNERBQTREOztBQUVuRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0Isb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7OztBQUd6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUEsaURBQWlELGFBQWE7O0FBRTlELENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LW1pbmltYWwtcGllLWNoYXJ0L2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdyZWFjdCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAncmVhY3QnXSwgZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5SZWFjdE1pbmltYWxQaWVDaGFydCA9IHt9LCBnbG9iYWwuUmVhY3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCBSZWFjdCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbiAgdmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG5cbiAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIGRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwO1xuICB9XG4gIGZ1bmN0aW9uIHZhbHVlQmV0d2Vlbih2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPiBtYXgpIHJldHVybiBtYXg7XG4gICAgaWYgKHZhbHVlIDwgbWluKSByZXR1cm4gbWluO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0UGVyY2VudGFnZSh2YWx1ZSwgcGVyY2VudGFnZSkge1xuICAgIHJldHVybiBwZXJjZW50YWdlIC8gMTAwICogdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gYmlzZWN0b3JBbmdsZShzdGFydEFuZ2xlLCBsZW5ndGhBbmdsZSkge1xuICAgIHJldHVybiBzdGFydEFuZ2xlICsgbGVuZ3RoQW5nbGUgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIHNoaWZ0VmVjdG9yQWxvbmdBbmdsZShhbmdsZSwgZGlzdGFuY2UpIHtcbiAgICB2YXIgYW5nbGVSYWRpYW5zID0gZGVncmVlc1RvUmFkaWFucyhhbmdsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlUmFkaWFucyksXG4gICAgICBkeTogZGlzdGFuY2UgKiBNYXRoLnNpbihhbmdsZVJhZGlhbnMpXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xuICB9XG4gIGZ1bmN0aW9uIGZ1bmN0aW9uUHJvcChwcm9wLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wID09PSAnZnVuY3Rpb24nID8gcHJvcChwYXlsb2FkKSA6IHByb3A7XG4gIH1cblxuICBmdW5jdGlvbiBzdW1WYWx1ZXMoZGF0YSkge1xuICAgIHZhciBzdW0gPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdW0gKz0gZGF0YVtpXS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xuICB9IC8vIEFwcGVuZCBcInBlcmNlbnRhZ2VcIiwgXCJkZWdyZWVzXCIgYW5kIFwic3RhcnRBbmdsZVwiIHRvIGVhY2ggZGF0YSBlbnRyeVxuXG5cbiAgZnVuY3Rpb24gZXh0ZW5kRGF0YShfcmVmKSB7XG4gICAgdmFyIGRhdGEgPSBfcmVmLmRhdGEsXG4gICAgICAgIHRvdGFsQW5nbGUgPSBfcmVmLmxlbmd0aEFuZ2xlLFxuICAgICAgICB0b3RhbFZhbHVlID0gX3JlZi50b3RhbFZhbHVlLFxuICAgICAgICBwYWRkaW5nQW5nbGUgPSBfcmVmLnBhZGRpbmdBbmdsZSxcbiAgICAgICAgY2hhcnRTdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlO1xuICAgIHZhciB0b3RhbCA9IHRvdGFsVmFsdWUgfHwgc3VtVmFsdWVzKGRhdGEpO1xuICAgIHZhciBub3JtYWxpemVkVG90YWxBbmdsZSA9IHZhbHVlQmV0d2Vlbih0b3RhbEFuZ2xlLCAtMzYwLCAzNjApO1xuICAgIHZhciBudW1iZXJPZlBhZGRpbmdzID0gTWF0aC5hYnMobm9ybWFsaXplZFRvdGFsQW5nbGUpID09PSAzNjAgPyBkYXRhLmxlbmd0aCA6IGRhdGEubGVuZ3RoIC0gMTtcbiAgICB2YXIgc2luZ2xlUGFkZGluZ0RlZ3JlZXMgPSBNYXRoLmFicyhwYWRkaW5nQW5nbGUpICogTWF0aC5zaWduKHRvdGFsQW5nbGUpO1xuICAgIHZhciBkZWdyZWVzVGFrZW5CeVBhZGRpbmcgPSBzaW5nbGVQYWRkaW5nRGVncmVlcyAqIG51bWJlck9mUGFkZGluZ3M7XG4gICAgdmFyIGRlZ3JlZXNUYWtlbkJ5UGF0aHMgPSBub3JtYWxpemVkVG90YWxBbmdsZSAtIGRlZ3JlZXNUYWtlbkJ5UGFkZGluZztcbiAgICB2YXIgbGFzdFNlZ21lbnRFbmQgPSAwO1xuICAgIHZhciBleHRlbmRlZERhdGEgPSBbXTsgLy8gQE5PVEU6IFNoYWxsIHdlIGV2YWx1YXRlIHBlcmNlbnRhZ2UgYWNjb3JkaW5nbHkgdG8gZGF0YUVudHJ5LnZhbHVlJ3Mgc2lnbj9cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRhdGFFbnRyeSA9IGRhdGFbaV07XG4gICAgICB2YXIgdmFsdWVJblBlcmNlbnRhZ2UgPSB0b3RhbCA9PT0gMCA/IDAgOiBkYXRhRW50cnkudmFsdWUgLyB0b3RhbCAqIDEwMDtcbiAgICAgIHZhciBkZWdyZWVzID0gZXh0cmFjdFBlcmNlbnRhZ2UoZGVncmVlc1Rha2VuQnlQYXRocywgdmFsdWVJblBlcmNlbnRhZ2UpO1xuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBsYXN0U2VnbWVudEVuZCArIGNoYXJ0U3RhcnRBbmdsZTtcbiAgICAgIGxhc3RTZWdtZW50RW5kID0gbGFzdFNlZ21lbnRFbmQgKyBkZWdyZWVzICsgc2luZ2xlUGFkZGluZ0RlZ3JlZXM7XG4gICAgICBleHRlbmRlZERhdGEucHVzaChPYmplY3QuYXNzaWduKHtcbiAgICAgICAgcGVyY2VudGFnZTogdmFsdWVJblBlcmNlbnRhZ2UsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGRlZ3JlZXM6IGRlZ3JlZXNcbiAgICAgIH0sIGRhdGFFbnRyeSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmRlZERhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IHt9O1xuICAgIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICB2YXIga2V5LCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gUmVhY3RNaW5pbWFsUGllQ2hhcnRMYWJlbChfcmVmKSB7XG4gICAgX3JlZi5kYXRhRW50cnk7XG4gICAgICAgIF9yZWYuZGF0YUluZGV4O1xuICAgICAgICB2YXIgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBbXCJkYXRhRW50cnlcIiwgXCJkYXRhSW5kZXhcIl0pO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgZG9taW5hbnRCYXNlbGluZTogXCJjZW50cmFsXCJcbiAgICB9LCBwcm9wcykpO1xuICB9XG5cbiAgZnVuY3Rpb24gcm91bmQobnVtYmVyKSB7XG4gICAgdmFyIGRpdmlzb3IgPSAxZTE0OyAvLyAxNCBkZWNpbWFsc1xuXG4gICAgcmV0dXJuIE1hdGgucm91bmQoKG51bWJlciArIE51bWJlci5FUFNJTE9OKSAqIGRpdmlzb3IpIC8gZGl2aXNvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV2YWx1YXRlVGV4dEFuY2hvclBvc2l0aW9uKF9yZWYpIHtcbiAgICB2YXIgbGFiZWxQb3NpdGlvbiA9IF9yZWYubGFiZWxQb3NpdGlvbixcbiAgICAgICAgbGluZVdpZHRoID0gX3JlZi5saW5lV2lkdGgsXG4gICAgICAgIGxhYmVsSG9yaXpvbnRhbFNoaWZ0ID0gX3JlZi5sYWJlbEhvcml6b250YWxTaGlmdDtcbiAgICB2YXIgZHggPSByb3VuZChsYWJlbEhvcml6b250YWxTaGlmdCk7IC8vIExhYmVsIGluIHRoZSB2ZXJ0aWNhbCBjZW50ZXJcblxuICAgIGlmIChkeCA9PT0gMCkge1xuICAgICAgcmV0dXJuICdtaWRkbGUnO1xuICAgIH0gLy8gT3V0d2FyZCBsYWJlbFxuXG5cbiAgICBpZiAobGFiZWxQb3NpdGlvbiA+IDEwMCkge1xuICAgICAgcmV0dXJuIGR4ID4gMCA/ICdzdGFydCcgOiAnZW5kJztcbiAgICB9IC8vIElud2FyZCBsYWJlbFxuXG5cbiAgICB2YXIgaW5uZXJSYWRpdXMgPSAxMDAgLSBsaW5lV2lkdGg7XG5cbiAgICBpZiAobGFiZWxQb3NpdGlvbiA8IGlubmVyUmFkaXVzKSB7XG4gICAgICByZXR1cm4gZHggPiAwID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgIH0gLy8gT3Zlcmx5aW5nIGxhYmVsXG5cblxuICAgIHJldHVybiAnbWlkZGxlJztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckxhYmVsRWxlbWVudChyZW5kZXJMYWJlbCwgbGFiZWxQcm9wcykge1xuICAgIHZhciBsYWJlbCA9IHJlbmRlckxhYmVsKGxhYmVsUHJvcHMpO1xuXG4gICAgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmNyZWF0ZUVsZW1lbnQoUmVhY3RNaW5pbWFsUGllQ2hhcnRMYWJlbCwgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGtleTogXCJsYWJlbC1cIiArIChsYWJlbFByb3BzLmRhdGFFbnRyeS5rZXkgfHwgbGFiZWxQcm9wcy5kYXRhSW5kZXgpXG4gICAgICB9LCBsYWJlbFByb3BzKSwgbGFiZWwpO1xuICAgIH1cblxuICAgIGlmIChSZWFjdF9fZGVmYXVsdFsnZGVmYXVsdCddLmlzVmFsaWRFbGVtZW50KGxhYmVsKSkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKGRhdGEsIHByb3BzKSB7XG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uIChkYXRhRW50cnksIGluZGV4KSB7XG4gICAgICB2YXIgX2Z1bmN0aW9uUHJvcDtcblxuICAgICAgdmFyIHNlZ21lbnRzU2hpZnQgPSAoX2Z1bmN0aW9uUHJvcCA9IGZ1bmN0aW9uUHJvcChwcm9wcy5zZWdtZW50c1NoaWZ0LCBpbmRleCkpICE9IG51bGwgPyBfZnVuY3Rpb25Qcm9wIDogMDtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSBleHRyYWN0UGVyY2VudGFnZShwcm9wcy5yYWRpdXMsIHByb3BzLmxhYmVsUG9zaXRpb24pICsgc2VnbWVudHNTaGlmdDtcblxuICAgICAgdmFyIF9zaGlmdFZlY3RvckFsb25nQW5nbCA9IHNoaWZ0VmVjdG9yQWxvbmdBbmdsZShiaXNlY3RvckFuZ2xlKGRhdGFFbnRyeS5zdGFydEFuZ2xlLCBkYXRhRW50cnkuZGVncmVlcyksIGRpc3RhbmNlRnJvbUNlbnRlciksXG4gICAgICAgICAgZHggPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHgsXG4gICAgICAgICAgZHkgPSBfc2hpZnRWZWN0b3JBbG9uZ0FuZ2wuZHk7IC8vIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgXCJsYWJlbFwiIGZ1bmN0aW9uIHByb3BcblxuXG4gICAgICB2YXIgbGFiZWxSZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgeDogcHJvcHMuY2VudGVyWzBdLFxuICAgICAgICB5OiBwcm9wcy5jZW50ZXJbMV0sXG4gICAgICAgIGR4OiBkeCxcbiAgICAgICAgZHk6IGR5LFxuICAgICAgICB0ZXh0QW5jaG9yOiBldmFsdWF0ZVRleHRBbmNob3JQb3NpdGlvbih7XG4gICAgICAgICAgbGFiZWxQb3NpdGlvbjogcHJvcHMubGFiZWxQb3NpdGlvbixcbiAgICAgICAgICBsaW5lV2lkdGg6IHByb3BzLmxpbmVXaWR0aCxcbiAgICAgICAgICBsYWJlbEhvcml6b250YWxTaGlmdDogZHhcbiAgICAgICAgfSksXG4gICAgICAgIGRhdGFFbnRyeTogZGF0YUVudHJ5LFxuICAgICAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgICAgICBzdHlsZTogZnVuY3Rpb25Qcm9wKHByb3BzLmxhYmVsU3R5bGUsIGluZGV4KVxuICAgICAgfTtcbiAgICAgIHJldHVybiBwcm9wcy5sYWJlbCAmJiByZW5kZXJMYWJlbEVsZW1lbnQocHJvcHMubGFiZWwsIGxhYmVsUmVuZGVyUHJvcHMpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHBhcnRpYWxDaXJjbGUgPSBmdW5jdGlvbiBwYXJ0aWFsQ2lyY2xlKGN4LCBjeSwgciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBsZW5ndGggPSBlbmQgLSBzdGFydDtcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIGZyb21YID0gciAqIE1hdGguY29zKHN0YXJ0KSArIGN4O1xuICAgIHZhciBmcm9tWSA9IHIgKiBNYXRoLnNpbihzdGFydCkgKyBjeTtcbiAgICB2YXIgdG9YID0gciAqIE1hdGguY29zKGVuZCkgKyBjeDtcbiAgICB2YXIgdG9ZID0gciAqIE1hdGguc2luKGVuZCkgKyBjeTtcbiAgICB2YXIgbGFyZ2UgPSBNYXRoLmFicyhsZW5ndGgpIDw9IE1hdGguUEkgPyAnMCcgOiAnMSc7XG4gICAgdmFyIHN3ZWVwID0gbGVuZ3RoIDwgMCA/ICcwJyA6ICcxJztcbiAgICByZXR1cm4gW1snTScsIGZyb21YLCBmcm9tWV0sIFsnQScsIHIsIHIsIDAsIGxhcmdlLCBzd2VlcCwgdG9YLCB0b1ldXTtcbiAgfTtcblxuICB2YXIgc3ZnUGFydGlhbENpcmNsZSA9IHBhcnRpYWxDaXJjbGU7XG5cbiAgZnVuY3Rpb24gbWFrZVBhdGhDb21tYW5kcyhjeCwgY3ksIHN0YXJ0QW5nbGUsIGxlbmd0aEFuZ2xlLCByYWRpdXMpIHtcbiAgICB2YXIgcGF0Y2hlZExlbmd0aEFuZ2xlID0gdmFsdWVCZXR3ZWVuKGxlbmd0aEFuZ2xlLCAtMzU5Ljk5OSwgMzU5Ljk5OSk7XG4gICAgcmV0dXJuIHN2Z1BhcnRpYWxDaXJjbGUoY3gsIGN5LCAvLyBjZW50ZXIgWCBhbmQgWVxuICAgIHJhZGl1cywgZGVncmVlc1RvUmFkaWFucyhzdGFydEFuZ2xlKSwgZGVncmVlc1RvUmFkaWFucyhzdGFydEFuZ2xlICsgcGF0Y2hlZExlbmd0aEFuZ2xlKSkubWFwKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICByZXR1cm4gY29tbWFuZC5qb2luKCcgJyk7XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIGZ1bmN0aW9uIFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aChfcmVmKSB7XG4gICAgdmFyIGN4ID0gX3JlZi5jeCxcbiAgICAgICAgY3kgPSBfcmVmLmN5LFxuICAgICAgICBsZW5ndGhBbmdsZSA9IF9yZWYubGVuZ3RoQW5nbGUsXG4gICAgICAgIGxpbmVXaWR0aCA9IF9yZWYubGluZVdpZHRoLFxuICAgICAgICByYWRpdXMgPSBfcmVmLnJhZGl1cyxcbiAgICAgICAgX3JlZiRzaGlmdCA9IF9yZWYuc2hpZnQsXG4gICAgICAgIHNoaWZ0ID0gX3JlZiRzaGlmdCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkc2hpZnQsXG4gICAgICAgIHJldmVhbCA9IF9yZWYucmV2ZWFsLFxuICAgICAgICByb3VuZGVkID0gX3JlZi5yb3VuZGVkLFxuICAgICAgICBzdGFydEFuZ2xlID0gX3JlZi5zdGFydEFuZ2xlLFxuICAgICAgICB0aXRsZSA9IF9yZWYudGl0bGUsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgW1wiY3hcIiwgXCJjeVwiLCBcImxlbmd0aEFuZ2xlXCIsIFwibGluZVdpZHRoXCIsIFwicmFkaXVzXCIsIFwic2hpZnRcIiwgXCJyZXZlYWxcIiwgXCJyb3VuZGVkXCIsIFwic3RhcnRBbmdsZVwiLCBcInRpdGxlXCJdKTtcblxuICAgIHZhciBwYXRoUmFkaXVzID0gcmFkaXVzIC0gbGluZVdpZHRoIC8gMjsgLy9ATk9URSBUaGlzIHNoaWZ0IG1pZ2h0IGJlIHJlbmRlcmVkIGFzIGEgdHJhbnNsYXRpb24gaW4gZnV0dXJlXG5cbiAgICB2YXIgX3NoaWZ0VmVjdG9yQWxvbmdBbmdsID0gc2hpZnRWZWN0b3JBbG9uZ0FuZ2xlKGJpc2VjdG9yQW5nbGUoc3RhcnRBbmdsZSwgbGVuZ3RoQW5nbGUpLCBzaGlmdCksXG4gICAgICAgIGR4ID0gX3NoaWZ0VmVjdG9yQWxvbmdBbmdsLmR4LFxuICAgICAgICBkeSA9IF9zaGlmdFZlY3RvckFsb25nQW5nbC5keTtcblxuICAgIHZhciBwYXRoQ29tbWFuZHMgPSBtYWtlUGF0aENvbW1hbmRzKGN4ICsgZHgsIGN5ICsgZHksIHN0YXJ0QW5nbGUsIGxlbmd0aEFuZ2xlLCBwYXRoUmFkaXVzKTtcbiAgICB2YXIgc3Ryb2tlRGFzaGFycmF5O1xuICAgIHZhciBzdHJva2VEYXNob2Zmc2V0OyAvLyBBbmltYXRlL2hpZGUgcGF0aHMgd2l0aCBcInN0cm9rZS1kYXNoYXJyYXlcIiArIFwic3Ryb2tlLWRhc2hvZmZzZXRcIlxuICAgIC8vIGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vc3ZnLWxpbmUtYW5pbWF0aW9uLXdvcmtzL1xuXG4gICAgaWYgKGlzTnVtYmVyKHJldmVhbCkpIHtcbiAgICAgIHZhciBwYXRoTGVuZ3RoID0gZGVncmVlc1RvUmFkaWFucyhwYXRoUmFkaXVzKSAqIGxlbmd0aEFuZ2xlO1xuICAgICAgc3Ryb2tlRGFzaGFycmF5ID0gTWF0aC5hYnMocGF0aExlbmd0aCk7XG4gICAgICBzdHJva2VEYXNob2Zmc2V0ID0gc3Ryb2tlRGFzaGFycmF5IC0gZXh0cmFjdFBlcmNlbnRhZ2Uoc3Ryb2tlRGFzaGFycmF5LCByZXZlYWwpO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgIGQ6IHBhdGhDb21tYW5kcyxcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlV2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgIHN0cm9rZURhc2hhcnJheTogc3Ryb2tlRGFzaGFycmF5LFxuICAgICAgc3Ryb2tlRGFzaG9mZnNldDogc3Ryb2tlRGFzaG9mZnNldCxcbiAgICAgIHN0cm9rZUxpbmVjYXA6IHJvdW5kZWQgPyAncm91bmQnIDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMpLCB0aXRsZSAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwgbnVsbCwgdGl0bGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbWJpbmVTZWdtZW50VHJhbnNpdGlvbnNTdHlsZShkdXJhdGlvbiwgZWFzaW5nLCBjdXN0b21TdHlsZSkge1xuICAgIC8vIE1lcmdlIGNoYXJ0J3MgYW5pbWF0aW9uIENTUyB0cmFuc2l0aW9uIHdpdGggXCJ0cmFuc2l0aW9uXCIgZm91bmQgdG8gY3VzdG9tU3R5bGVcbiAgICB2YXIgdHJhbnNpdGlvbiA9IFwic3Ryb2tlLWRhc2hvZmZzZXQgXCIgKyBkdXJhdGlvbiArIFwibXMgXCIgKyBlYXNpbmc7XG5cbiAgICBpZiAoY3VzdG9tU3R5bGUgJiYgY3VzdG9tU3R5bGUudHJhbnNpdGlvbikge1xuICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gKyBcIixcIiArIGN1c3RvbVN0eWxlLnRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb25cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmV2ZWFsVmFsdWUocHJvcHMpIHtcbiAgICAvL0BOT1RFIFdoZW4gYW5pbWF0aW9uIGlzIG9uLCBjaGFydCBoYXMgdG8gYmUgZnVsbHkgcmV2ZWFsZWQgd2hlbiByZXZlYWwgaXMgbm90IHNldFxuICAgIGlmIChwcm9wcy5hbmltYXRlICYmICFpc051bWJlcihwcm9wcy5yZXZlYWwpKSB7XG4gICAgICByZXR1cm4gMTAwO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wcy5yZXZlYWw7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRXZlbnRIYW5kbGVyKGV2ZW50SGFuZGxlciwgcGF5bG9hZCkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIgJiYgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGV2ZW50SGFuZGxlcihlLCBwYXlsb2FkKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyU2VnbWVudHMoZGF0YSwgcHJvcHMsIHJldmVhbE92ZXJyaWRlKSB7XG4gICAgLy8gQE5PVEUgdGhpcyBzaG91bGQgZ28gaW4gUGF0aCBjb21wb25lbnQuIEhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgICB2YXIgcmV2ZWFsID0gcmV2ZWFsT3ZlcnJpZGUgIT0gbnVsbCA/IHJldmVhbE92ZXJyaWRlIDogZ2V0UmV2ZWFsVmFsdWUocHJvcHMpO1xuICAgIHZhciByYWRpdXMgPSBwcm9wcy5yYWRpdXMsXG4gICAgICAgIF9wcm9wcyRjZW50ZXIgPSBwcm9wcy5jZW50ZXIsXG4gICAgICAgIGN4ID0gX3Byb3BzJGNlbnRlclswXSxcbiAgICAgICAgY3kgPSBfcHJvcHMkY2VudGVyWzFdO1xuICAgIHZhciBsaW5lV2lkdGggPSBleHRyYWN0UGVyY2VudGFnZShyYWRpdXMsIHByb3BzLmxpbmVXaWR0aCk7XG4gICAgdmFyIHBhdGhzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGRhdGFFbnRyeSwgaW5kZXgpIHtcbiAgICAgIHZhciBzZWdtZW50c1N0eWxlID0gZnVuY3Rpb25Qcm9wKHByb3BzLnNlZ21lbnRzU3R5bGUsIGluZGV4KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFJlYWN0TWluaW1hbFBpZUNoYXJ0UGF0aCwge1xuICAgICAgICBjeDogY3gsXG4gICAgICAgIGN5OiBjeSxcbiAgICAgICAga2V5OiBkYXRhRW50cnkua2V5IHx8IGluZGV4LFxuICAgICAgICBsZW5ndGhBbmdsZTogZGF0YUVudHJ5LmRlZ3JlZXMsXG4gICAgICAgIGxpbmVXaWR0aDogbGluZVdpZHRoLFxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgcm91bmRlZDogcHJvcHMucm91bmRlZCxcbiAgICAgICAgcmV2ZWFsOiByZXZlYWwsXG4gICAgICAgIHNoaWZ0OiBmdW5jdGlvblByb3AocHJvcHMuc2VnbWVudHNTaGlmdCwgaW5kZXgpLFxuICAgICAgICBzdGFydEFuZ2xlOiBkYXRhRW50cnkuc3RhcnRBbmdsZSxcbiAgICAgICAgdGl0bGU6IGRhdGFFbnRyeS50aXRsZSxcbiAgICAgICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oe30sIHNlZ21lbnRzU3R5bGUsIHByb3BzLmFuaW1hdGUgJiYgY29tYmluZVNlZ21lbnRUcmFuc2l0aW9uc1N0eWxlKHByb3BzLmFuaW1hdGlvbkR1cmF0aW9uLCBwcm9wcy5hbmltYXRpb25FYXNpbmcsIHNlZ21lbnRzU3R5bGUpKSxcbiAgICAgICAgc3Ryb2tlOiBkYXRhRW50cnkuY29sb3IsXG4gICAgICAgIHRhYkluZGV4OiBwcm9wcy5zZWdtZW50c1RhYkluZGV4LFxuICAgICAgICBvbkJsdXI6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25CbHVyLCBpbmRleCksXG4gICAgICAgIG9uQ2xpY2s6IG1ha2VFdmVudEhhbmRsZXIocHJvcHMub25DbGljaywgaW5kZXgpLFxuICAgICAgICBvbkZvY3VzOiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uRm9jdXMsIGluZGV4KSxcbiAgICAgICAgb25LZXlEb3duOiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uS2V5RG93biwgaW5kZXgpLFxuICAgICAgICBvbk1vdXNlT3ZlcjogbWFrZUV2ZW50SGFuZGxlcihwcm9wcy5vbk1vdXNlT3ZlciwgaW5kZXgpLFxuICAgICAgICBvbk1vdXNlT3V0OiBtYWtlRXZlbnRIYW5kbGVyKHByb3BzLm9uTW91c2VPdXQsIGluZGV4KVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAocHJvcHMuYmFja2dyb3VuZCkge1xuICAgICAgcGF0aHMudW5zaGlmdCggLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0WydkZWZhdWx0J10uY3JlYXRlRWxlbWVudChSZWFjdE1pbmltYWxQaWVDaGFydFBhdGgsIHtcbiAgICAgICAgY3g6IGN4LFxuICAgICAgICBjeTogY3ksXG4gICAgICAgIGtleTogXCJiZ1wiLFxuICAgICAgICBsZW5ndGhBbmdsZTogcHJvcHMubGVuZ3RoQW5nbGUsXG4gICAgICAgIGxpbmVXaWR0aDogbGluZVdpZHRoLFxuICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgcm91bmRlZDogcHJvcHMucm91bmRlZCxcbiAgICAgICAgc3RhcnRBbmdsZTogcHJvcHMuc3RhcnRBbmdsZSxcbiAgICAgICAgc3Ryb2tlOiBwcm9wcy5iYWNrZ3JvdW5kXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2Vhc2Utb3V0JyxcbiAgICBjZW50ZXI6IFs1MCwgNTBdLFxuICAgIGRhdGE6IFtdLFxuICAgIGxhYmVsUG9zaXRpb246IDUwLFxuICAgIGxlbmd0aEFuZ2xlOiAzNjAsXG4gICAgbGluZVdpZHRoOiAxMDAsXG4gICAgcGFkZGluZ0FuZ2xlOiAwLFxuICAgIHJhZGl1czogNTAsXG4gICAgc3RhcnRBbmdsZTogMCxcbiAgICB2aWV3Qm94U2l6ZTogWzEwMCwgMTAwXVxuICB9O1xuICBmdW5jdGlvbiBSZWFjdE1pbmltYWxQaWVDaGFydChwcm9wcykge1xuICAgIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShwcm9wcy5hbmltYXRlID8gMCA6IG51bGwpLFxuICAgICAgICByZXZlYWxPdmVycmlkZSA9IF91c2VTdGF0ZVswXSxcbiAgICAgICAgc2V0UmV2ZWFsT3ZlcnJpZGUgPSBfdXNlU3RhdGVbMV07XG5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb3BzLmFuaW1hdGUpIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5pdGlhbEFuaW1hdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGFydEluaXRpYWxBbmltYXRpb24oKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25UaW1lcklkO1xuICAgICAgICB2YXIgYW5pbWF0aW9uUkFGSWQ7XG4gICAgICAgIGFuaW1hdGlvblRpbWVySWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhbmltYXRpb25UaW1lcklkID0gbnVsbDtcbiAgICAgICAgICBhbmltYXRpb25SQUZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhbmltYXRpb25SQUZJZCA9IG51bGw7XG4gICAgICAgICAgICBzZXRSZXZlYWxPdmVycmlkZShudWxsKTsgLy8gU3RhcnQgYW5pbWF0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGFuaW1hdGlvblRpbWVySWQgJiYgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblRpbWVySWQpO1xuICAgICAgICAgIGFuaW1hdGlvblJBRklkICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblJBRklkKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdmFyIGV4dGVuZGVkRGF0YSA9IGV4dGVuZERhdGEocHJvcHMpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbJ2RlZmF1bHQnXS5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHtcbiAgICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgcHJvcHMudmlld0JveFNpemVbMF0gKyBcIiBcIiArIHByb3BzLnZpZXdCb3hTaXplWzFdLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgIGNsYXNzTmFtZTogcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgc3R5bGU6IHByb3BzLnN0eWxlXG4gICAgfSwgcmVuZGVyU2VnbWVudHMoZXh0ZW5kZWREYXRhLCBwcm9wcywgcmV2ZWFsT3ZlcnJpZGUpLCBwcm9wcy5sYWJlbCAmJiByZW5kZXJMYWJlbHMoZXh0ZW5kZWREYXRhLCBwcm9wcyksIHByb3BzLmNoaWxkcmVuKTtcbiAgfVxuICBSZWFjdE1pbmltYWxQaWVDaGFydC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5cbiAgZXhwb3J0cy5QaWVDaGFydCA9IFJlYWN0TWluaW1hbFBpZUNoYXJ0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==